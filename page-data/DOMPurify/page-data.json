{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/DOMPurify/",
    "result": {"data":{"cur":{"id":"6b77466b-9b4a-5a39-95ef-0580d9b40ced","html":"<h1 id=\"intro\" style=\"position:relative;\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intro…</h1>\n <br />\n 회사에서 열심히 주어진 핫픽스를 하던 와중, \n <br />\n 낯서디 낯선 마크다운 렌더러를 만지게 되는데.\n <br />\n<p>임무는 외부링크로 연결되는 a태그를 새로운 창에서 열리게 하는 것이었다. <br />\n회사는 마크다운으로 회사 랜딩페이지의 글들을 렌더링하고 있었다. <br />\n렌더링 된 html에 <code class=\"language-text\">target=\"\\_blank\"</code> 속성을 넣고 팀장님이 이건 근본적인 해결이 아니라고 코멘트 해주셨다. <br /></p>\n<p>마크다운 문법을 html로 렌더링 시키는 렌더러에서 작업을 수행해야 했는데, <br />\n묘하게도 <code class=\"language-text\">target=\"\\_blank\"</code>속성만 DOM에 나타나지 않았다. <br />\n묘한일이다 묘한일이야… 뭔가 이상한데, 하며 입사 2주차였던 나는 선뜻 물어보지도 못하고 <br />\n머리를 꽁꽁 싸매고 있었다.</p>\n<p>이유는 뭐였을까?</p>\n <br />\n<h1 id=\"원인\" style=\"position:relative;\"><a href=\"#%EC%9B%90%EC%9D%B8\" aria-label=\"원인 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>원인</h1>\n<p>범인은 <a href=\"https://github.com/cure53/DOMPurify\">DOM Purify</a> 였다.</p>\n<blockquote>\n<p>Dom Purify는 악성 스크립트를 삽입하는 XSS 공격을 막기 위한 라이브러리다.<br>\n깃허브를 보면 더러운 HTML을 깨끗한 HTML로 바꿔준다고 나와 있다.</p>\n</blockquote>\n<p>DOM Purify가 html을 살균하면서 보안에 취약한 <code class=\"language-text\">target=\"\\_blank\"</code>을 더티코드로 인식해 제거해버린 것이다.</p>\n<br />\n<h3 id=\"code-classlanguage-texttarget_blankcode-왜-보안에-취약할까\" style=\"position:relative;\"><a href=\"#code-classlanguage-texttarget_blankcode-%EC%99%9C-%EB%B3%B4%EC%95%88%EC%97%90-%EC%B7%A8%EC%95%BD%ED%95%A0%EA%B9%8C\" aria-label=\"code classlanguage texttarget_blankcode 왜 보안에 취약할까 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code class=\"language-text\">target=\"\\_blank\"</code> 왜 보안에 취약할까?</h3>\n<ul>\n<li>해당 속성들을 살펴보면서 알아보자</li>\n</ul>\n<blockquote>\n<p><code class=\"language-text\">&lt;a href=\"https://www.google.com/\" target=\"_blank\" rel=\"noopener noreferrer\"></code> <br /><br />\n이 둘은 보통 짝으로 같이 다니게 되는데, <code class=\"language-text\">rel</code> 속성은 낯설다.<br />\n<code class=\"language-text\">rel</code>은 연결된 리소스와 현재 문서 간의 관계를 정의하는 속성이다. <br />\n리소스가 연결되는 <code class=\"language-text\">&lt;link></code>, <code class=\"language-text\">&lt;a></code>, <code class=\"language-text\">&lt;area></code>, <code class=\"language-text\">&lt;form></code>에서 사용하는데 각 태그마다 올 수 있는 값이 다르다.</p>\n</blockquote>\n  <br />\n<ul>\n<li>\n<p>noopener</p>\n<ul>\n<li><code class=\"language-text\">&lt;a></code>, <code class=\"language-text\">&lt;area></code>, <code class=\"language-text\">&lt;form></code>에서 쓸 수 있다.</li>\n<li>새롭게 열린 브라우징 컨텍스트에 해당 리소스를 연 문서에 대한 접근 권한을 부여하지 않고 대상 리소스를 탐색하도록 브라우저에 지시한다.</li>\n<li>새롭게 열린 창에 window.opener 속성을 부여하지 않는다. (null을 반환)</li>\n<li>즉, 새롭게 열린 창이 원본의 창을 참조하지 못하게 막아준다.</li>\n<li>완전히 신뢰할 수 없는 링크와 연결 할 때 꼭 써야 한다.</li>\n<li><a href=\"https://mathiasbynens.github.io/rel-noopener/\">이 문서</a>에서 아주 자세히 설명해주고 있다.</li>\n</ul>\n</li>\n<li>\n<p>noreferrer</p>\n</li>\n<li>\n<p>다른 페이지를 탐색할 때, 페이지의 주소나 다른 값들을 HTTP 헤더를 통해 보내는 것을 막는다.</p>\n</li>\n</ul>\n<br />\n<h1 id=\"문제를-해결한-방법\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EC%A0%9C%EB%A5%BC-%ED%95%B4%EA%B2%B0%ED%95%9C-%EB%B0%A9%EB%B2%95\" aria-label=\"문제를 해결한 방법 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문제를 해결한 방법</h1>\n<ul>\n<li>바로 DOMPutify 공식홈페이지에 들어갔다. 역시 반복해서 제기됐던 문제였는지, 커스텀 훅을 제공하고 있었다.</li>\n</ul>\n<p><a href=\"https://fossies.org/linux/DOMPurify/demos/README.md#:~:text=Hook%20to%20open%20all%20links%20in%20a%20new%20window\">링크</a></p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// Add a hook to make all links open a new window\nDOMPurify.addHook('afterSanitizeAttributes', function (node) {\n  // set all elements owning target to target=_blank\n  if ('target' in node) {\n    node.setAttribute('target', '_blank');\n  }\n  // set non-HTML/MathML links to xlink:show=new\n  if (\n    !node.hasAttribute('target') &amp;&amp;\n    (node.hasAttribute('xlink:href') || node.hasAttribute('href'))\n  ) {\n    node.setAttribute('xlink:show', 'new');\n  }\n});\n\n// Clean HTML string and write into our DIV\nvar clean = DOMPurify.sanitize(dirty);</code></pre></div>\n<ul>\n<li>간단히 해결되었다…!</li>\n</ul>\n<br />\n<h1 id=\"outro\" style=\"position:relative;\"><a href=\"#outro\" aria-label=\"outro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>outro…</h1>\n<p>꼬박 이틀을 바친…</p>\n<p>좀 헤매게 된다면 정리해서 바로 사수에게 물어보는 것도 좋을듯 하다.\n그치만 정말 좋은 경험이었다.</p>\n<p>‘못할 것 같다’라고 생각했었는데 결국엔 해냈을 때, ‘어떤 일도 할 수 있다’라는 데이터가 축적되면 더 재밌게 개발할 수 있지 않을까?</p>","excerpt":"Intro… 임무는 외부링크로 연결되는 a태그를 새로운 창에서 열리게 하는 것이었다. \n회사는 마크다운으로 회사 랜딩페이지의 글들을 렌더링하고 있었다. \n렌더링 된 html에  속성을 넣고 팀장님이 이건 근본적인 해결이 아니라고 코멘트 해주셨다.  마크다운 문법을 html로 렌더링 시키는 렌더러에서 작업을 수행해야 했는데, \n묘하게도 속성만 DOM에 나타나지 않았다. \n묘한일이다 묘한일이야… 뭔가 이상한데, 하며 입사 2주차였던 나는 선뜻 물어보지도 못하고 \n머리를 꽁꽁 싸매고 있었다. 이유는 뭐였을까? 원인 범인은 DOM Purify 였다. Dom Purify는 악성 스크립트를 삽입하는 XSS 공격을 막기 위한 라이브러리다. 깃허브를 보면 더러운 HTML을 깨끗한 HTML로 바꿔준다고 나와 있다. DOM Purify가 html을 살균하면서 보안에 취약한 을 더티코드로 인식해 제거해버린 것이다.  왜 보안에 취약할까? 해당 속성들을 살펴보면서 알아보자  \n이 둘은 보통 짝으로 같이…","frontmatter":{"date":"November 01, 2021","title":"Error/ DOM에 렌더링 될 때 target=\"\\_blank\" 속성이 사라져요! , Renderer remove my attribute!","categories":"Error","author":"양다은","emoji":"💧"},"fields":{"slug":"/DOMPurify/"}},"next":{"id":"86a56f1e-ba52-5c48-968b-326d31484ff8","html":"<h1 id=\"intro\" style=\"position:relative;\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intro…</h1>\n<p>리액트의 lifecycle은 세 단계로 구분할 수 있다.</p>\n<figure>\n<img src=\"./lifecycle.png\" />\n<figcaption>출처: https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\n</figcaption>\n</caption>\n</figure>\n<br>\n<p><code class=\"language-text\">Mounting -> Updating -> Unmounting</code>\n리액트의 각 컴포넌트들은 모두 위의 라이프사이클을 따른다. 우리는 <code class=\"language-text\">lifecycle method</code>를 이용하여 라이프사이클의 특정 단계에서 원하는 코드를 실행하도록 할 수 있다.</p>\n<ul>\n<li><code class=\"language-text\">Mounting</code>는 돔에 요소들을 넣는 단계다.</li>\n<li><code class=\"language-text\">Updating</code>는 말 그대로 컴포넌트가 업데이트 되는 단계다.</li>\n<li><code class=\"language-text\">Unmounting</code>는 돔에서 컴포넌트가 제거되는 단계다.</li>\n</ul>\n<p>자세히 살펴보자.</p>\n<h1 id=\"mounting\" style=\"position:relative;\"><a href=\"#mounting\" aria-label=\"mounting permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mounting</h1>\n<p>컴포넌트의 인스턴스가 생성이 되고 돔에 삽입될 때, 아래의 <code class=\"language-text\">lifecycle method</code>들은 다음과 같은 순서로 호출이 된다.</p>\n<p>(클래스형 컴포넌트만 컴포넌트 인스턴스를 가진다. 컴포넌트 클래스 내부에서 this 키워드를 통해 참조하는 대상에 해당)</p>\n<p>(굵은 글씨의 함수가 자주 쓰이는 함수다.)</p>\n<ol>\n<li><b>constructor()</b></li>\n<li>static getDerivedStateFromProps()</li>\n<li><b>render()</b></li>\n<li><b>componentDidMount()</b></li>\n</ol>\n<blockquote>\n<p>⚠️주의<br>UNSAFE_componentWillMount() 함수는 legacy code로 여겨지고 있기 때문에 지양된다.</p>\n</blockquote>\n<p>render()함수는 필수고 항상 호출되며, 나머지 함수들은 선택사항이다.</p>\n<h2 id=\"constructor--mount-전에-호출\" style=\"position:relative;\"><a href=\"#constructor--mount-%EC%A0%84%EC%97%90-%ED%98%B8%EC%B6%9C\" aria-label=\"constructor  mount 전에 호출 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>constructor() : mount 전에 호출</h2>\n<ul>\n<li>\n<p>constuctor()함수는 컴포넌트가 생성될 때 제일 먼저 호출된다.</p>\n</li>\n<li>\n<p>constructor()메서드는 인자인 props와 함께 호출되기 때문에 내부에 제일 먼저 <code class=\"language-text\">super(props)</code>를 선언해주어야 한다. <code class=\"language-text\">super(props)</code>는 부모 컴포넌트의 constructor method를 생성해주고, 컴포넌트가 부모 컴포넌트로부터 상속받게 해준다.</p>\n</li>\n<li>\n<p>대표적으로 아래 두 가지의 목적으로 쓰인다.</p>\n<ul>\n<li>초기 local state, 초기 value을 세팅\n<ul>\n<li>state는 객체로 할당이 된다.</li>\n</ul>\n</li>\n<li>인스턴스에 event handler를 binding</li>\n</ul>\n</li>\n<li>\n<p>constructor()안에서 초기 값을 세팅하거나 event handler를 bind할 땐, setState함수를 사용하지 않고 직접 할당을 한다.</p>\n<p>state를 직접 할당할 수 있는 유일한 곳이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">constructor(props) {\nsuper(props);\n// Don't call this.setState() here!\nthis.state = { counter: 0 };\nthis.handleClick = this.handleClick.bind(this);\n}</code></pre></div>\n</li>\n<li>\n<p>local state가 필요없거나 method를 bind할 필요 없다면 constructor()를 구현 할 필요가 없다. (optional)</p>\n</li>\n<li>\n<p>constructor()안에서 side-effects를 발생시키거나 subscriptions을 하지 않는다. (componentDidMount()에서 진행한다)</p>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">constructor(props) {\n super(props);\n // Don't do this!\n this.state = { color: props.color };\n}</code></pre></div>\n<ul>\n<li>위 코드의 잘못된 점\n<ul>\n<li>props.color를 직접 this.props.color로 사용하면 된다.</li>\n<li>props가 state에 반영되기 전에 color를 update하려고 해 버그가 난다.</li>\n<li>update되지 않는 color의 초기값을 할당하고 싶을 때만, intialColor 등의 이름으로 사용한다. 초기값으로 reset할 때 사용.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"componentdidmount--mount된-직후\" style=\"position:relative;\"><a href=\"#componentdidmount--mount%EB%90%9C-%EC%A7%81%ED%9B%84\" aria-label=\"componentdidmount  mount된 직후 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>componentDidMount() : mount된 직후</h2>\n<ul>\n<li>tree에 컴포넌트가 삽입되자마자 즉, mount되자마자 호출된다.</li>\n<li>데이터를 로드해야 된다면 네트워크 요청하기 좋은 곳이다.</li>\n<li>구독하기도 좋은 곳이다. 구독했으면 componentWillUnmount()에서 구독해제하는 것도 잊지 말자!</li>\n<li>여기서 setState()하게 되면 렌더링을 두 번 요청하게 되더라도 아직 브라우저는 스크린에 업데이트 하기 전이므로 사용자는 즉시 업데이트 된 페이지를 보게 된다.</li>\n</ul>\n<h1 id=\"updating\" style=\"position:relative;\"><a href=\"#updating\" aria-label=\"updating permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Updating</h1>\n<p>컴포넌트는 컴포넌트의 <code class=\"language-text\">state</code>나 <code class=\"language-text\">props</code>에 변화가 생길 때 업데이트 된다.</p>\n<p>다음과 같은 순서로 업데이트 된다</p>\n<ol>\n<li>getDerivedStateFromProps()</li>\n<li>shouldComponentUpdate()</li>\n<li>render()</li>\n<li>getSnapshotBeforeUpdate()</li>\n<li>componentDidUpdate()</li>\n</ol>\n<p>마찬가지로 render()는 필수적으로 요구되며 나머지 함수들은 optional이다.</p>\n<h2 id=\"rarely-used-static-getderivedstatefromprops\" style=\"position:relative;\"><a href=\"#rarely-used-static-getderivedstatefromprops\" aria-label=\"rarely used static getderivedstatefromprops permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[rarely used] static getDerivedStateFromProps</h2>\n<ul>\n<li>업데이트 시 최초로 호출되는 함수다.</li>\n<li>업데이트 된 객체를 반환하거나 업데이트 된 부분이 없으면 null을 반환한다.</li>\n<li>initial props를 state에 세팅하기 좋은 장소다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Header extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {favoritecolor: \"red\"};\n  }\n  static getDerivedStateFromProps(props, state) {\n    return {favoritecolor: props.favcol };\n  }\n  changeColor = () => {\n    this.setState({favoritecolor: \"blue\"});\n  }\n  render() {\n    return (\n      &lt;div>\n      &lt;h1>My Favorite Color is {this.state.favoritecolor}&lt;/h1>\n      &lt;button type=\"button\" onClick={this.changeColor}>Change color&lt;/button>\n      &lt;/div>\n    );\n  }\n}\n\nReactDOM.render(&lt;Header favcol=\"yellow\"/>, document.getElementById('root'));</code></pre></div>\n<p>버튼을 누르면 changeColor함수가 호출되면서 favoritecolor가 blue로 변경되는 업데이트가 일어나고, 그 직후 getDerivedStateFromProps함수가 호출되기 때문에 favoritecolor는 props로 받은 yellow로 렌더링 된다.</p>\n<ul>\n<li>props를 받아서 데이터 페칭하거나 애니메이션 효과를 주는 등의 side effect를 원한다면 componentDidUpdate()에서 하는 게 좋다.</li>\n</ul>\n<h2 id=\"rarely-used-shouldcomponentupdate\" style=\"position:relative;\"><a href=\"#rarely-used-shouldcomponentupdate\" aria-label=\"rarely used shouldcomponentupdate permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[rarely used] shouldComponentUpdate()</h2>\n<ul>\n<li>\n<p>shouldComponentUpdate(nextProps, nextState)</p>\n</li>\n<li>\n<p>리액트가 렌더링을 계속 해야 하는지의 여부를 boolean값으로 반환한다.</p>\n</li>\n<li>\n<p>더 구체적으로 말하면 컴포넌트의 출력(페이지)이 현재 state나 props의 변화에 영향을 받았는지 여부다.</p>\n</li>\n<li>\n<p>기본적으로는 모든 state가 변할 때마다 리렌더가 일어난다.</p>\n</li>\n<li>\n<p>새로운 props나 state를 받았을 때 렌더링 전에 함수가 호출이 되며, 초기렌더링이나 forceUpdate()시에는 호출되지 않는다.</p>\n</li>\n<li>\n<p>렌더링을 방지하기 위해 쓰면 버그를 일으킬 수 있고, 오직 성능 최적화를 위해 쓴다.</p>\n</li>\n<li>\n<p>직접 이 메서드를 작성하기보다 내장된 pureComponent(얕은 비교로 shouldComponentUpdate()가 구현되고 필요한 업데이트를 뛰어넘을 확률을 줄여줌)를 쓰는 걸 추천한다.</p>\n</li>\n<li>\n<p>이 메서드가 false를 반환하면 뒤의 UNSAFE_componentWillUpdate(), render(), and componentDidUpdate()는 호출되지 않는다.</p>\n</li>\n</ul>\n<h2 id=\"render\" style=\"position:relative;\"><a href=\"#render\" aria-label=\"render permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>render()</h2>\n<ul>\n<li>업데이트 시 새로운 변경사항과 함께 HTML을 DOM에 다시 렌더링 합니다.</li>\n</ul>\n<h2 id=\"rarely-used-getsnapshotbeforeupdate\" style=\"position:relative;\"><a href=\"#rarely-used-getsnapshotbeforeupdate\" aria-label=\"rarely used getsnapshotbeforeupdate permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[rarely used] getSnapshotBeforeUpdate</h2>\n<ul>\n<li>업데이트 전에 props와 state 값에 접근할 수 있는 함수입니다.</li>\n<li>말인 즉슨, 업데이트가 일어난 후에도 업데이트 전의 값을 확인할 수 있습니다.</li>\n<li>componentDidUpdate()와 같이 써야 합니다. 안 그럼 에러 발생!</li>\n<li>아래와 같이 사용합니다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Header extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {favoritecolor: \"red\"};\n  }\n  componentDidMount() {\n    setTimeout(() => {\n      this.setState({favoritecolor: \"yellow\"})\n    }, 1000)\n  }\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    document.getElementById(\"div1\").innerHTML =\n    \"Before the update, the favorite was \" + prevState.favoritecolor;\n  }\n  componentDidUpdate() {\n    document.getElementById(\"div2\").innerHTML =\n    \"The updated favorite is \" + this.state.favoritecolor;\n  }\n  render() {\n    return (\n      &lt;div>\n        &lt;h1>My Favorite Color is {this.state.favoritecolor}&lt;/h1>\n        &lt;div id=\"div1\">&lt;/div>\n        &lt;div id=\"div2\">&lt;/div>\n      &lt;/div>\n    );\n  }\n}\n\nReactDOM.render(&lt;Header />, document.getElementById('root'));</code></pre></div>\n<h2 id=\"componentdidupdate\" style=\"position:relative;\"><a href=\"#componentdidupdate\" aria-label=\"componentdidupdate permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>componentDidUpdate()</h2>\n<ul>\n<li>componentDidUpdate(prevProps, prevState, snapshot)</li>\n<li>DOM에 update가 되자 마자 호출된다. 최초 렌더링 시에는 호출X</li>\n<li>어떤 값의 변화에 따라 네트워크 요청을 해야할 때 쓴다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">componentDidUpdate(prevProps) {\n  // Typical usage (don't forget to compare props):\n  if (this.props.userID !== prevProps.userID) {\n    this.fetchData(this.props.userID);\n  }\n}</code></pre></div>\n<ul>\n<li>여기서 setState를 할 땐, 꼭 조건문으로 감싸야 한다. 안그럼 무한 루프에 빠진다.</li>\n<li>또 추가적으로 리렌더링을 발생시키기 때문에 유저에게 영향은 없더라도 퍼포먼스에 영향을 줄 수 있다.</li>\n<li>shouldComponentUpdate() 가 false를 반환하면 호출되지 않는다.</li>\n</ul>\n<h1 id=\"unmounting\" style=\"position:relative;\"><a href=\"#unmounting\" aria-label=\"unmounting permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Unmounting</h1>\n<p>위에서 말했듯이, DOM에 컴포넌트가 제거되는 단계입니다.</p>\n<p>마운트가 해제될 때 호출될 수 있는 메서드가 componentWillUnmount 하나입니다.</p>\n<h2 id=\"componentwillunmount\" style=\"position:relative;\"><a href=\"#componentwillunmount\" aria-label=\"componentwillunmount permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>componentWillUnmount</h2>\n<ul>\n<li>컴포넌트가 DOM에서 제거되려고 하기 직전에 호출됩니다.</li>\n<li>타이머를 무효화 하거나 네트워크 요청을 취소하거나 또는, componentDidMount()에서 만든 구독을 해제하는 등의 필수적인 cleanup을 여기서 구현하면 됩니다.</li>\n<li>여기서 setState는 하지 마세요. 리렌더링 절대 안됩니다. 컴포넌트 인스턴스가 한 번 언마운트 되면 다시는 마운트되지 않습니다.</li>\n</ul>","frontmatter":{"date":"October 22, 2021","title":"React/ React Lifecycle 정복하기","categories":"React","author":"양다은","emoji":"😎"},"fields":{"slug":"/react_lifecycle/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://www.zoomkoding.com","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/DOMPurify/","nextSlug":"/react_lifecycle/","prevSlug":""}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}