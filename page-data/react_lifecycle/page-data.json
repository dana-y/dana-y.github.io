{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/react_lifecycle/",
    "result": {"data":{"cur":{"id":"86a56f1e-ba52-5c48-968b-326d31484ff8","html":"<h1 id=\"intro\" style=\"position:relative;\"><a href=\"#intro\" aria-label=\"intro permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Intro…</h1>\n<p>리액트의 lifecycle은 세 단계로 구분할 수 있다.</p>\n<figure>\n<span class=\"gatsby-resp-image-wrapper\" style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \">\n      <span class=\"gatsby-resp-image-background-image\" style=\"padding-bottom: 56.111111111111114%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACBElEQVQoz2WTW27bMBREvYYmdiTxKVEU9ZZlxbGTtEkfQLv/FZ2CdFoU6AcxwCV17p0htdtnij8rFyXdcOR8ecX5nkKWSFOTy5LpeObp+gVTBQpZIbVDmZplfUr1tl/ICsvukCkOmSaq0B4XVqb1BetnhK6pXIut4grUzfBXtW2Quk4a96PGRrv7g+DTfcHdvkCYFtddGE/v2Gaj0IE6zLhmxlQdTXfEup5u3NBlQGiXHCS4qW9AH0Yuz2807ZgAql6R7piAETxt74ynN9r5NdWkW9H+EWm7D9seUzZJE3CYVr5+/8kwnciFTbmY0qO0Q6iKunukm19op2tSGQHWp3PR8n/A/UeG+weZMlTlkPJTZY+wHWG8pimn4UIZNuTHvkwZ3ibU/wKzwqTbyQqNtC26XjF+TarcQjOc8d2GdhNVOGJ9jGNFl/9aDjegqtjF6z5fPjMtW7KcCZvCjk3ywlBXgmVwXM8zr88rT9vAEDS2LMlllWKJ9qPG73exS3xzsYNSiuAknTcEp1jnwHZsOc0hQYdgaGvJ0GiMMdwfJHd7wf5BJT3k+jbhtx+/GOeNXCpCVzMtfVLfeELnaYfAuAyMc48PFaaSCGUotMXWnrrtUFWVYtvFMePrj39JrgxhGRlOR/zYs88VByUQztAuE+NHPTOSTGqsrxlOM+NpIcw9mTD8Blz/OLR/kabzAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"></span>\n  <img class=\"gatsby-resp-image-image\" alt=\"lifecycle\" title=\"lifecycle\" src=\"/static/d2008cf023c6a82cbd530313192c797a/37523/lifecycle.png\" srcset=\"/static/d2008cf023c6a82cbd530313192c797a/e9ff0/lifecycle.png 180w,\n/static/d2008cf023c6a82cbd530313192c797a/f21e7/lifecycle.png 360w,\n/static/d2008cf023c6a82cbd530313192c797a/37523/lifecycle.png 720w,\n/static/d2008cf023c6a82cbd530313192c797a/302a4/lifecycle.png 1080w,\n/static/d2008cf023c6a82cbd530313192c797a/07a9c/lifecycle.png 1440w,\n/static/d2008cf023c6a82cbd530313192c797a/15171/lifecycle.png 2230w\" sizes=\"(max-width: 720px) 100vw, 720px\" style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\" loading=\"lazy\" decoding=\"async\">\n    </span></figure>\n<figcaption>출처: https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\n</figcaption>\n</caption>\n</figure>\n<br>\n<p><code class=\"language-text\">Mounting -> Updating -> Unmounting</code>\n리액트의 각 컴포넌트들은 모두 위의 라이프사이클을 따른다. 우리는 <code class=\"language-text\">lifecycle method</code>를 이용하여 라이프사이클의 특정 단계에서 원하는 코드를 실행하도록 할 수 있다.</p>\n<ul>\n<li><code class=\"language-text\">Mounting</code>는 돔에 요소들을 넣는 단계다.</li>\n<li><code class=\"language-text\">Updating</code>는 말 그대로 컴포넌트가 업데이트 되는 단계다.</li>\n<li><code class=\"language-text\">Unmounting</code>는 돔에서 컴포넌트가 제거되는 단계다.</li>\n</ul>\n<p>자세히 살펴보자.</p>\n<h1 id=\"mounting\" style=\"position:relative;\"><a href=\"#mounting\" aria-label=\"mounting permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Mounting</h1>\n<p>컴포넌트의 인스턴스가 생성이 되고 돔에 삽입될 때, 아래의 <code class=\"language-text\">lifecycle method</code>들은 다음과 같은 순서로 호출이 된다.</p>\n<p>(클래스형 컴포넌트만 컴포넌트 인스턴스를 가진다. 컴포넌트 클래스 내부에서 this 키워드를 통해 참조하는 대상에 해당)</p>\n<p>(굵은 글씨의 함수가 자주 쓰이는 함수다.)</p>\n<ol>\n<li><b>constructor()</b></li>\n<li>static getDerivedStateFromProps()</li>\n<li><b>render()</b></li>\n<li><b>componentDidMount()</b></li>\n</ol>\n<blockquote>\n<p>⚠️주의<br>UNSAFE_componentWillMount() 함수는 legacy code로 여겨지고 있기 때문에 지양된다.</p>\n</blockquote>\n<p>render()함수는 필수고 항상 호출되며, 나머지 함수들은 선택사항이다.</p>\n<h2 id=\"constructor--mount-전에-호출\" style=\"position:relative;\"><a href=\"#constructor--mount-%EC%A0%84%EC%97%90-%ED%98%B8%EC%B6%9C\" aria-label=\"constructor  mount 전에 호출 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>constructor() : mount 전에 호출</h2>\n<ul>\n<li>\n<p>constuctor()함수는 컴포넌트가 생성될 때 제일 먼저 호출된다.</p>\n</li>\n<li>\n<p>constructor()메서드는 인자인 props와 함께 호출되기 때문에 내부에 제일 먼저 <code class=\"language-text\">super(props)</code>를 선언해주어야 한다. <code class=\"language-text\">super(props)</code>는 부모 컴포넌트의 constructor method를 생성해주고, 컴포넌트가 부모 컴포넌트로부터 상속받게 해준다.</p>\n</li>\n<li>\n<p>대표적으로 아래 두 가지의 목적으로 쓰인다.</p>\n<ul>\n<li>초기 local state, 초기 value을 세팅\n<ul>\n<li>state는 객체로 할당이 된다.</li>\n</ul>\n</li>\n<li>인스턴스에 event handler를 binding</li>\n</ul>\n</li>\n<li>\n<p>constructor()안에서 초기 값을 세팅하거나 event handler를 bind할 땐, setState함수를 사용하지 않고 직접 할당을 한다.</p>\n<p>state를 직접 할당할 수 있는 유일한 곳이다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">constructor(props) {\nsuper(props);\n// Don't call this.setState() here!\nthis.state = { counter: 0 };\nthis.handleClick = this.handleClick.bind(this);\n}</code></pre></div>\n</li>\n<li>\n<p>local state가 필요없거나 method를 bind할 필요 없다면 constructor()를 구현 할 필요가 없다. (optional)</p>\n</li>\n<li>\n<p>constructor()안에서 side-effects를 발생시키거나 subscriptions을 하지 않는다. (componentDidMount()에서 진행한다)</p>\n</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">constructor(props) {\n super(props);\n // Don't do this!\n this.state = { color: props.color };\n}</code></pre></div>\n<ul>\n<li>위 코드의 잘못된 점\n<ul>\n<li>props.color를 직접 this.props.color로 사용하면 된다.</li>\n<li>props가 state에 반영되기 전에 color를 update하려고 해 버그가 난다.</li>\n<li>update되지 않는 color의 초기값을 할당하고 싶을 때만, intialColor 등의 이름으로 사용한다. 초기값으로 reset할 때 사용.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"componentdidmount--mount된-직후\" style=\"position:relative;\"><a href=\"#componentdidmount--mount%EB%90%9C-%EC%A7%81%ED%9B%84\" aria-label=\"componentdidmount  mount된 직후 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>componentDidMount() : mount된 직후</h2>\n<ul>\n<li>tree에 컴포넌트가 삽입되자마자 즉, mount되자마자 호출된다.</li>\n<li>데이터를 로드해야 된다면 네트워크 요청하기 좋은 곳이다.</li>\n<li>구독하기도 좋은 곳이다. 구독했으면 componentWillUnmount()에서 구독해제하는 것도 잊지 말자!</li>\n<li>여기서 setState()하게 되면 렌더링을 두 번 요청하게 되더라도 아직 브라우저는 스크린에 업데이트 하기 전이므로 사용자는 즉시 업데이트 된 페이지를 보게 된다.</li>\n</ul>\n<h1 id=\"updating\" style=\"position:relative;\"><a href=\"#updating\" aria-label=\"updating permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Updating</h1>\n<p>컴포넌트는 컴포넌트의 <code class=\"language-text\">state</code>나 <code class=\"language-text\">props</code>에 변화가 생길 때 업데이트 된다.</p>\n<p>다음과 같은 순서로 업데이트 된다</p>\n<ol>\n<li>getDerivedStateFromProps()</li>\n<li>shouldComponentUpdate()</li>\n<li>render()</li>\n<li>getSnapshotBeforeUpdate()</li>\n<li>componentDidUpdate()</li>\n</ol>\n<p>마찬가지로 render()는 필수적으로 요구되며 나머지 함수들은 optional이다.</p>\n<h2 id=\"rarely-used-static-getderivedstatefromprops\" style=\"position:relative;\"><a href=\"#rarely-used-static-getderivedstatefromprops\" aria-label=\"rarely used static getderivedstatefromprops permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[rarely used] static getDerivedStateFromProps</h2>\n<ul>\n<li>업데이트 시 최초로 호출되는 함수다.</li>\n<li>업데이트 된 객체를 반환하거나 업데이트 된 부분이 없으면 null을 반환한다.</li>\n<li>initial props를 state에 세팅하기 좋은 장소다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Header extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {favoritecolor: \"red\"};\n  }\n  static getDerivedStateFromProps(props, state) {\n    return {favoritecolor: props.favcol };\n  }\n  changeColor = () => {\n    this.setState({favoritecolor: \"blue\"});\n  }\n  render() {\n    return (\n      &lt;div>\n      &lt;h1>My Favorite Color is {this.state.favoritecolor}&lt;/h1>\n      &lt;button type=\"button\" onClick={this.changeColor}>Change color&lt;/button>\n      &lt;/div>\n    );\n  }\n}\n\nReactDOM.render(&lt;Header favcol=\"yellow\"/>, document.getElementById('root'));</code></pre></div>\n<p>버튼을 누르면 changeColor함수가 호출되면서 favoritecolor가 blue로 변경되는 업데이트가 일어나고, 그 직후 getDerivedStateFromProps함수가 호출되기 때문에 favoritecolor는 props로 받은 yellow로 렌더링 된다.</p>\n<ul>\n<li>props를 받아서 데이터 페칭하거나 애니메이션 효과를 주는 등의 side effect를 원한다면 componentDidUpdate()에서 하는 게 좋다.</li>\n</ul>\n<h2 id=\"rarely-used-shouldcomponentupdate\" style=\"position:relative;\"><a href=\"#rarely-used-shouldcomponentupdate\" aria-label=\"rarely used shouldcomponentupdate permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[rarely used] shouldComponentUpdate()</h2>\n<ul>\n<li>\n<p>shouldComponentUpdate(nextProps, nextState)</p>\n</li>\n<li>\n<p>리액트가 렌더링을 계속 해야 하는지의 여부를 boolean값으로 반환한다.</p>\n</li>\n<li>\n<p>더 구체적으로 말하면 컴포넌트의 출력(페이지)이 현재 state나 props의 변화에 영향을 받았는지 여부다.</p>\n</li>\n<li>\n<p>기본적으로는 모든 state가 변할 때마다 리렌더가 일어난다.</p>\n</li>\n<li>\n<p>새로운 props나 state를 받았을 때 렌더링 전에 함수가 호출이 되며, 초기렌더링이나 forceUpdate()시에는 호출되지 않는다.</p>\n</li>\n<li>\n<p>렌더링을 방지하기 위해 쓰면 버그를 일으킬 수 있고, 오직 성능 최적화를 위해 쓴다.</p>\n</li>\n<li>\n<p>직접 이 메서드를 작성하기보다 내장된 pureComponent(얕은 비교로 shouldComponentUpdate()가 구현되고 필요한 업데이트를 뛰어넘을 확률을 줄여줌)를 쓰는 걸 추천한다.</p>\n</li>\n<li>\n<p>이 메서드가 false를 반환하면 뒤의 UNSAFE_componentWillUpdate(), render(), and componentDidUpdate()는 호출되지 않는다.</p>\n</li>\n</ul>\n<h2 id=\"render\" style=\"position:relative;\"><a href=\"#render\" aria-label=\"render permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>render()</h2>\n<ul>\n<li>업데이트 시 새로운 변경사항과 함께 HTML을 DOM에 다시 렌더링 합니다.</li>\n</ul>\n<h2 id=\"rarely-used-getsnapshotbeforeupdate\" style=\"position:relative;\"><a href=\"#rarely-used-getsnapshotbeforeupdate\" aria-label=\"rarely used getsnapshotbeforeupdate permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>[rarely used] getSnapshotBeforeUpdate</h2>\n<ul>\n<li>업데이트 전에 props와 state 값에 접근할 수 있는 함수입니다.</li>\n<li>말인 즉슨, 업데이트가 일어난 후에도 업데이트 전의 값을 확인할 수 있습니다.</li>\n<li>componentDidUpdate()와 같이 써야 합니다. 안 그럼 에러 발생!</li>\n<li>아래와 같이 사용합니다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">class Header extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {favoritecolor: \"red\"};\n  }\n  componentDidMount() {\n    setTimeout(() => {\n      this.setState({favoritecolor: \"yellow\"})\n    }, 1000)\n  }\n  getSnapshotBeforeUpdate(prevProps, prevState) {\n    document.getElementById(\"div1\").innerHTML =\n    \"Before the update, the favorite was \" + prevState.favoritecolor;\n  }\n  componentDidUpdate() {\n    document.getElementById(\"div2\").innerHTML =\n    \"The updated favorite is \" + this.state.favoritecolor;\n  }\n  render() {\n    return (\n      &lt;div>\n        &lt;h1>My Favorite Color is {this.state.favoritecolor}&lt;/h1>\n        &lt;div id=\"div1\">&lt;/div>\n        &lt;div id=\"div2\">&lt;/div>\n      &lt;/div>\n    );\n  }\n}\n\nReactDOM.render(&lt;Header />, document.getElementById('root'));</code></pre></div>\n<h2 id=\"componentdidupdate\" style=\"position:relative;\"><a href=\"#componentdidupdate\" aria-label=\"componentdidupdate permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>componentDidUpdate()</h2>\n<ul>\n<li>componentDidUpdate(prevProps, prevState, snapshot)</li>\n<li>DOM에 update가 되자 마자 호출된다. 최초 렌더링 시에는 호출X</li>\n<li>어떤 값의 변화에 따라 네트워크 요청을 해야할 때 쓴다.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">componentDidUpdate(prevProps) {\n  // Typical usage (don't forget to compare props):\n  if (this.props.userID !== prevProps.userID) {\n    this.fetchData(this.props.userID);\n  }\n}</code></pre></div>\n<ul>\n<li>여기서 setState를 할 땐, 꼭 조건문으로 감싸야 한다. 안그럼 무한 루프에 빠진다.</li>\n<li>또 추가적으로 리렌더링을 발생시키기 때문에 유저에게 영향은 없더라도 퍼포먼스에 영향을 줄 수 있다.</li>\n<li>shouldComponentUpdate() 가 false를 반환하면 호출되지 않는다.</li>\n</ul>\n<h1 id=\"unmounting\" style=\"position:relative;\"><a href=\"#unmounting\" aria-label=\"unmounting permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Unmounting</h1>\n<p>위에서 말했듯이, DOM에 컴포넌트가 제거되는 단계입니다.</p>\n<p>마운트가 해제될 때 호출될 수 있는 메서드가 componentWillUnmount 하나입니다.</p>\n<h2 id=\"componentwillunmount\" style=\"position:relative;\"><a href=\"#componentwillunmount\" aria-label=\"componentwillunmount permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>componentWillUnmount</h2>\n<ul>\n<li>컴포넌트가 DOM에서 제거되려고 하기 직전에 호출됩니다.</li>\n<li>타이머를 무효화 하거나 네트워크 요청을 취소하거나 또는, componentDidMount()에서 만든 구독을 해제하는 등의 필수적인 cleanup을 여기서 구현하면 됩니다.</li>\n<li>여기서 setState는 하지 마세요. 리렌더링 절대 안됩니다. 컴포넌트 인스턴스가 한 번 언마운트 되면 다시는 마운트되지 않습니다.</li>\n</ul>","excerpt":"Intro… 리액트의 lifecycle은 세 단계로 구분할 수 있다. \n리액트의 각 컴포넌트들은 모두 위의 라이프사이클을 따른다. 우리는 를 이용하여 라이프사이클의 특정 단계에서 원하는 코드를 실행하도록 할 수 있다. 는 돔에 요소들을 넣는 단계다. 는 말 그대로 컴포넌트가 업데이트 되는 단계다. 는 돔에서 컴포넌트가 제거되는 단계다. 자세히 살펴보자. Mounting 컴포넌트의 인스턴스가 생성이 되고 돔에 삽입될 때, 아래의 들은 다음과 같은 순서로 호출이 된다. (클래스형 컴포넌트만 컴포넌트 인스턴스를 가진다. 컴포넌트 클래스 내부에서 this 키워드를 통해 참조하는 대상에 해당) (굵은 글씨의 함수가 자주 쓰이는 함수다.) ⚠️주의UNSAFE_componentWillMount() 함수는 legacy code로 여겨지고 있기 때문에 지양된다. render()함수는 필수고 항상 호출되며, 나머지 함수들은 선택사항이다. constructor() : mount 전에 호출 constuc…","frontmatter":{"date":"October 22, 2021","title":"React/ React Lifecycle 정복하기","categories":"React","author":"양다은","emoji":"😎"},"fields":{"slug":"/react_lifecycle/"}},"next":null,"prev":{"id":"d9f91328-f84f-5e3d-bcb1-52514d904c34","html":"<h1 id=\"state-올바르게-사용하기-3원칙\" style=\"position:relative;\"><a href=\"#state-%EC%98%AC%EB%B0%94%EB%A5%B4%EA%B2%8C-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-3%EC%9B%90%EC%B9%99\" aria-label=\"state 올바르게 사용하기 3원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>state 올바르게 사용하기: 3원칙</h1>\n<h2 id=\"01-state를-직접-수정하지-않습니다\" style=\"position:relative;\"><a href=\"#01-state%EB%A5%BC-%EC%A7%81%EC%A0%91-%EC%88%98%EC%A0%95%ED%95%98%EC%A7%80-%EC%95%8A%EC%8A%B5%EB%8B%88%EB%8B%A4\" aria-label=\"01 state를 직접 수정하지 않습니다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>01 state를 직접 수정하지 않습니다</h2>\n<p>this.state를 지정할 수 있는 공간은 constructor 뿐입니다.(초기 세팅)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">    class Clock extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {date: new Date()};\n  }\n\n  render() {\n    return (\n      &lt;div>\n        &lt;h1>Hello, world!&lt;/h1>\n        &lt;h2>It is {this.state.date.toLocaleTimeString()}.&lt;/h2>\n      &lt;/div>\n    );\n  }\n}</code></pre></div>\n<p>클래스 컴포넌트는 항상 props로 기본 constructor를 호출해야 합니다.</p>\n<p>다음과 같이 쓰여진 코드는 리렌더링 되지 않을 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// Wrong\nthis.state.comment = 'Hello';</code></pre></div>\n<p>대신에, setState를 사용해야 합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// Correct\nthis.setState({comment: 'Hello'});</code></pre></div>\n<br>\n<h2 id=\"02-state-업데이트는-비동기적일-수-있습니다\" style=\"position:relative;\"><a href=\"#02-state-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%EB%8A%94-%EB%B9%84%EB%8F%99%EA%B8%B0%EC%A0%81%EC%9D%BC-%EC%88%98-%EC%9E%88%EC%8A%B5%EB%8B%88%EB%8B%A4\" aria-label=\"02 state 업데이트는 비동기적일 수 있습니다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>02 state 업데이트는 비동기적일 수 있습니다</h2>\n<p>다음과 같이 props와 기존 state를 한꺼번에 처리하는 경우가 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// Wrong\nthis.setState({\n  counter: this.state.counter + this.props.increment,\n});</code></pre></div>\n<p>this.props와 this.state는 비동기적으로 업데이트 될 수 있기 때문에 객체 형식이 아닌 함수를 인자로 사용하는 형태를 사용합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">// Correct\n// 화살표 함수\nthis.setState((state, props) => ({\n  counter: state.counter + props.increment\n}));\n\n// 일반 함수\nthis.setState(function(state, props) {\n  return {\n    counter: state.counter + props.increment\n  };\n});</code></pre></div>\n<br>\n<h2 id=\"03-state의-업데이트는-병합됩니다\" style=\"position:relative;\"><a href=\"#03-state%EC%9D%98-%EC%97%85%EB%8D%B0%EC%9D%B4%ED%8A%B8%EB%8A%94-%EB%B3%91%ED%95%A9%EB%90%A9%EB%8B%88%EB%8B%A4\" aria-label=\"03 state의 업데이트는 병합됩니다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>03 state의 업데이트는 병합됩니다</h2>\n<p>state는 객체형태로 지정이 가능합니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> constructor(props) {\n    super(props);\n    this.state = {\n      posts: [],\n      comments: []\n    };\n  }</code></pre></div>\n<p>다양한 독립적인 변수를 포함할 수 있는데, 이러한 변수들을 또 독립적으로 업데이트 할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> componentDidMount() {\n    // posts만 업데이트\n    fetchPosts().then(response => {\n      this.setState({\n        posts: response.posts\n      });\n    });\n\n    // comments만 업데이트\n    fetchComments().then(response => {\n      this.setState({\n        comments: response.comments\n      });\n    });\n  }</code></pre></div>\n<p>this.setState({comments})를 진행할 때 this.state.posts에 영향을 주지 않으며,\n병합은 얕게 이루어지므로 this.state.comments는 완전히 교체된다.</p>\n<p>(깊은 병합 deep merge, 얕은 병합 shallow merge 참고: <a href=\"https://velog.io/@jonmad/JS-Object-Deep-Merging-Shallow-Merging\">https://velog.io/@jonmad/JS-Object-Deep-Merging-Shallow-Merging</a>)</p>","frontmatter":{"date":"October 22, 2021","title":"React/ state 올바르게 사용하기","categories":"React","author":"양다은","emoji":"😎"},"fields":{"slug":"/test/"}},"site":{"siteMetadata":{"siteUrl":"https://www.zoomkoding.com","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/react_lifecycle/","nextSlug":"","prevSlug":"/test/"}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}